# üöÄ APPLICATION LAYER (CQRS) - IMPLEMENTACI√ìN POR LOTES# üöÄ PLAN MAESTRO: Implementaci√≥n de Application Layer (CQRS con MediatR)



**Fecha de Creaci√≥n:** 12 de octubre, 2025  **Fecha de Creaci√≥n:** 12 de octubre, 2025  

**Proyecto:** MiGente En L√≠nea - Clean Architecture Migration  **Estado:** ‚è≥ **PENDIENTE - LISTO PARA EJECUTAR**  

**Fase:** Phase 4 - Application Layer (CQRS con MediatR)**Prerequisitos:** ‚úÖ Domain Layer (36 entidades), ‚úÖ Infrastructure (relaciones), ‚úÖ Program.cs configurado



------



## üéØ OBJETIVO PRINCIPAL## üéØ OBJETIVO GENERAL



Migrar **TODA** la l√≥gica de negocio de los servicios legacy (`.asmx.cs`, `*Service.cs`) a **CQRS** usando **MediatR**, manteniendo la **l√≥gica EXACTAMENTE igual** al sistema legacy.Migrar la l√≥gica de negocio desde los **22 servicios Legacy** (Web Forms) a **Application Layer** usando **CQRS** con **MediatR**. La l√≥gica de negocio debe ser **EXACTAMENTE ID√âNTICA** al proyecto Legacy para garantizar compatibilidad funcional.



‚ö†Ô∏è **REGLA CR√çTICA:** Antes de implementar cualquier Command/Query, SIEMPRE leer el m√©todo correspondiente en Legacy para copiar la l√≥gica exacta (validaciones, c√°lculos, reglas de negocio, excepciones).### ‚ö†Ô∏è REGLA CR√çTICA: PARIDAD 100% CON LEGACY



---```

ANTES de implementar cualquier Command/Query/Handler:

## üìä SERVICIOS LEGACY ANALIZADOS

1. LEE el servicio/controlador Legacy correspondiente

### 1. LoginService.asmx.cs (10 m√©todos) - LOTE 12. IDENTIFICA el m√©todo exacto y su l√≥gica

### 2. EmpleadosService.cs (30+ m√©todos) - LOTE 43. ANALIZA los par√°metros de entrada y salida

### 3. ContratistasService.cs (10 m√©todos) - LOTE 34. REPLICA la l√≥gica EXACTAMENTE (mismos pasos, mismas validaciones, mismo orden)

### 4. SuscripcionesService.cs (15+ m√©todos) - LOTE 55. USA las mismas queries EF Core (ajustadas a DbContext moderno)

### 5. PaymentService.cs (3 m√©todos) - LOTE 56. MANT√âN los mismos nombres de campos en DTOs

### 6. CalificacionesService.cs (4 m√©todos) - LOTE 67. RESPETA los mismos c√≥digos de retorno y mensajes de error

```

Ver archivo completo en el prompt para detalles de cada servicio.

**NO inventes l√≥gica nueva. NO mejores la l√≥gica sin autorizaci√≥n expl√≠cita. COPIA el comportamiento Legacy al 100%.**

---

---

## üì¶ LOTE 1: AUTHENTICATION & USER MANAGEMENT

## üìä INVENTARIO DE SERVICIOS LEGACY

**Prioridad:** üî¥ CR√çTICA  

**Tiempo Estimado:** 8-10 horas### Servicios Identificados (22 total)



### Servicios Legacy:| # | Servicio Legacy | Ubicaci√≥n | M√©todos P√∫blicos | Prioridad | Lote |

- LoginService.asmx.cs|---|-----------------|-----------|------------------|-----------|------|

- SuscripcionesService.cs (registro)| 1 | **LoginService.asmx.cs** | Services/ | 11 m√©todos | üî¥ CR√çTICA | LOTE 1 |

| 2 | **EmpleadosService.cs** | Services/ | 15 m√©todos | üü† ALTA | LOTE 4 |

### Commands & Queries a Implementar:| 3 | **ContratistasService.cs** | Services/ | 10 m√©todos | üü† ALTA | LOTE 3 |

| 4 | **CalificacionesService.cs** | Services/ | 6 m√©todos | üü° MEDIA | LOTE 5 |

Ver archivo completo en el workspace.| 5 | **SuscripcionesService.cs** | Services/ | 8 m√©todos | üü° MEDIA | LOTE 5 |

| 6 | **PaymentService.cs** | Services/ | 5 m√©todos | üü° MEDIA | LOTE 5 |

---| 7 | **EmailService.cs** | Services/ | 4 m√©todos | üü¢ BAJA | LOTE 6 |

| 8 | **BotServices.cs** | Services/ | 3 m√©todos | üü¢ BAJA | LOTE 7 |

## üöÄ COMANDO DE EJECUCI√ìN| 9-22 | Otros servicios auxiliares | Services/ | Variable | üü¢ BAJA | LOTE 6-7 |



```bash---

@workspace Lee prompts/APPLICATION_LAYER_CQRS_IMPLEMENTATION.md

## üéØ ORGANIZACI√ìN POR LOTES (CQRS)

EJECUTAR: LOTE 1 - AUTHENTICATION & USER MANAGEMENT

### ‚ö†Ô∏è METODOLOG√çA POR LOTE

METODOLOG√çA OBLIGATORIA:

1. ‚úÖ LEER Legacy PRIMERO (LoginService.asmx.cs)Cada LOTE sigue este workflow estricto:

2. ‚úÖ Implementar Command + Handler + Validator

3. ‚úÖ Copiar l√≥gica EXACTA del Legacy```

4. ‚úÖ Crear DTOs con AutoMapperPARA CADA SERVICIO EN EL LOTE:

5. ‚úÖ Crear Controller con documentaci√≥n

6. ‚úÖ Probar con Swagger1. üìñ LEER SERVICIO LEGACY

7. ‚úÖ Documentar en LOTE_1_COMPLETADO.md   - Ubicar archivo en Codigo Fuente Mi Gente/MiGente_Front/Services/

   - Identificar TODOS los m√©todos p√∫blicos

COMENZAR EJECUCI√ìN AUTOM√ÅTICA.   - Anotar firma (par√°metros, retorno)

```   - Entender la l√≥gica paso a paso



---2. üìù CLASIFICAR OPERACIONES

   - COMMAND: Si modifica datos (INSERT, UPDATE, DELETE)

**Estado:** Listo para ejecuci√≥n ‚úÖ   - QUERY: Si solo lee datos (SELECT)


3. ‚úèÔ∏è CREAR COMMAND/QUERY
   Ubicaci√≥n: src/Core/MiGenteEnLinea.Application/Features/[M√≥dulo]/Commands o Queries/
   
   Ejemplo: LoginCommand.cs
   ```csharp
   public record LoginCommand(string Email, string Password) : IRequest<LoginResult>;
   ```

4. üõ†Ô∏è CREAR HANDLER
   Ubicaci√≥n: Mismo folder que Command/Query
   
   Ejemplo: LoginCommandHandler.cs
   ```csharp
   public class LoginCommandHandler : IRequestHandler<LoginCommand, LoginResult>
   {
       private readonly MiGenteDbContext _context;
       private readonly IPasswordHasher _passwordHasher;
       
       public LoginCommandHandler(MiGenteDbContext context, IPasswordHasher passwordHasher)
       {
           _context = context;
           _passwordHasher = passwordHasher;
       }
       
       public async Task<LoginResult> Handle(LoginCommand request, CancellationToken ct)
       {
           // AQU√ç: Copiar l√≥gica EXACTA del m√©todo login() en LoginService.asmx.cs
           
           // Ejemplo de paridad:
           // LEGACY: var result = db.Credenciales.Where(x => x.email == email && x.password == crypted).FirstOrDefault();
           // CLEAN:  var credencial = await _context.Credenciales.Where(x => x.Email == request.Email).FirstOrDefaultAsync(ct);
           
           // IMPORTANTE: Mantener el mismo orden de operaciones, mismas validaciones, mismos c√≥digos de retorno
       }
   }
   ```

5. ‚úÖ CREAR VALIDATOR
   Ubicaci√≥n: src/Core/MiGenteEnLinea.Application/Features/[M√≥dulo]/Validators/
   
   Ejemplo: LoginCommandValidator.cs
   ```csharp
   public class LoginCommandValidator : AbstractValidator<LoginCommand>
   {
       public LoginCommandValidator()
       {
           RuleFor(x => x.Email)
               .NotEmpty().WithMessage("El correo electr√≥nico es requerido")
               .EmailAddress().WithMessage("El correo electr√≥nico no es v√°lido");
               
           RuleFor(x => x.Password)
               .NotEmpty().WithMessage("La contrase√±a es requerida")
               .MinimumLength(6).WithMessage("La contrase√±a debe tener al menos 6 caracteres");
       }
   }
   ```

6. üì¶ CREAR DTOs
   Ubicaci√≥n: src/Core/MiGenteEnLinea.Application/Features/[M√≥dulo]/DTOs/
   
   Ejemplo: LoginResult.cs
   ```csharp
   public class LoginResult
   {
       public int StatusCode { get; set; } // 2=success, 0=invalid, -1=inactive (IGUAL AL LEGACY)
       public string? UserId { get; set; }
       public string? Email { get; set; }
       public string? Nombre { get; set; }
       public int? Tipo { get; set; } // 1=Empleador, 2=Contratista
       public int? PlanId { get; set; }
       public DateTime? VencimientoPlan { get; set; }
   }
   ```

7. üåê CREAR CONTROLLER ENDPOINT
   Ubicaci√≥n: src/Presentation/MiGenteEnLinea.API/Controllers/
   
   Ejemplo: AuthController.cs
   ```csharp
   [ApiController]
   [Route("api/[controller]")]
   public class AuthController : ControllerBase
   {
       private readonly IMediator _mediator;
       
       public AuthController(IMediator mediator)
       {
           _mediator = mediator;
       }
       
       [HttpPost("login")]
       public async Task<ActionResult<LoginResult>> Login([FromBody] LoginCommand command)
       {
           var result = await _mediator.Send(command);
           
           if (result.StatusCode == 0)
               return Unauthorized(new { message = "Credenciales inv√°lidas" });
           
           if (result.StatusCode == -1)
               return Unauthorized(new { message = "Cuenta inactiva" });
               
           return Ok(result);
       }
   }
   ```

8. üß™ VALIDAR COMPILACI√ìN
   ```bash
   dotnet build --no-restore
   # Esperado: Build succeeded. 0 Error(s)
   ```

9. üìÑ DOCUMENTAR
   - Crear LOTE_X_[MODULO]_COMPLETADO.md
   - Listar Commands/Queries implementados
   - Comparar con Legacy (tabla de paridad)
   - Notas de diferencias (si las hay)
```

---

## üî¥ LOTE 1: AUTHENTICATION (CR√çTICO)

**Prioridad:** üî¥ **M√ÅXIMA - COMENZAR AQU√ç**  
**Servicio Legacy:** `LoginService.asmx.cs`  
**Ubicaci√≥n:** `Codigo Fuente Mi Gente/MiGente_Front/Services/LoginService.asmx.cs`  
**Duraci√≥n Estimada:** 4-6 horas  
**Estado:** ‚è≥ PENDIENTE

### M√©todos a Migrar (11 total)

| # | M√©todo Legacy | Operaci√≥n | Command/Query | Descripci√≥n | Prioridad |
|---|---------------|-----------|---------------|-------------|-----------|
| 1 | `login(string email, string pass)` | READ/WRITE | **LoginCommand** | Autenticaci√≥n + cookie | üî¥ CR√çTICA |
| 2 | `obtenerPerfil(string userID)` | READ | **GetPerfilQuery** | Obtener perfil VPerfiles | üü† ALTA |
| 3 | `obtenerPerfilByEmail(string email)` | READ | **GetPerfilByEmailQuery** | Buscar perfil por email | üü† ALTA |
| 4 | `getPerfilByID(int cuentaID)` | READ | **GetPerfilByIdQuery** | Obtener Cuenta por ID | üü† ALTA |
| 5 | `getPerfilInfo(Guid userID)` | READ | **GetPerfilInfoQuery** | Obtener VPerfiles por GUID | üü° MEDIA |
| 6 | `obtenerCredenciales(string userID)` | READ | **GetCredencialesQuery** | Lista credenciales user | üü° MEDIA |
| 7 | `validarCorreo(string correo)` | READ | **ValidarCorreoQuery** | Check email exists | üü° MEDIA |
| 8 | `actualizarPerfil(perfilesInfo, Cuentas)` | WRITE | **ActualizarPerfilCommand** | Update perfil completo | üü° MEDIA |
| 9 | `actualizarPerfil1(Cuentas cuenta)` | WRITE | **ActualizarCuentaCommand** | Update solo Cuenta | üü° MEDIA |
| 10 | `agregarPerfilInfo(perfilesInfo info)` | WRITE | **AgregarPerfilInfoCommand** | Agregar perfilesInfo | üü¢ BAJA |
| 11 | `borrarUsuario(string userID, int credencialID)` | WRITE | **BorrarUsuarioCommand** | Eliminar usuario | üü¢ BAJA |

### Estructura de Archivos LOTE 1

```
src/Core/MiGenteEnLinea.Application/Features/Authentication/
‚îú‚îÄ‚îÄ Commands/
‚îÇ   ‚îú‚îÄ‚îÄ Login/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginCommand.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginCommandHandler.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LoginCommandValidator.cs
‚îÇ   ‚îú‚îÄ‚îÄ ActualizarPerfil/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ActualizarPerfilCommand.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ActualizarPerfilCommandHandler.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ActualizarPerfilCommandValidator.cs
‚îÇ   ‚îú‚îÄ‚îÄ ActualizarCuenta/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ActualizarCuentaCommand.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ActualizarCuentaCommandHandler.cs
‚îÇ   ‚îú‚îÄ‚îÄ AgregarPerfilInfo/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AgregarPerfilInfoCommand.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AgregarPerfilInfoCommandHandler.cs
‚îÇ   ‚îî‚îÄ‚îÄ BorrarUsuario/
‚îÇ       ‚îú‚îÄ‚îÄ BorrarUsuarioCommand.cs
‚îÇ       ‚îî‚îÄ‚îÄ BorrarUsuarioCommandHandler.cs
‚îú‚îÄ‚îÄ Queries/
‚îÇ   ‚îú‚îÄ‚îÄ GetPerfil/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GetPerfilQuery.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetPerfilQueryHandler.cs
‚îÇ   ‚îú‚îÄ‚îÄ GetPerfilByEmail/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GetPerfilByEmailQuery.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetPerfilByEmailQueryHandler.cs
‚îÇ   ‚îú‚îÄ‚îÄ GetPerfilById/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GetPerfilByIdQuery.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetPerfilByIdQueryHandler.cs
‚îÇ   ‚îú‚îÄ‚îÄ GetPerfilInfo/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GetPerfilInfoQuery.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetPerfilInfoQueryHandler.cs
‚îÇ   ‚îú‚îÄ‚îÄ GetCredenciales/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GetCredencialesQuery.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetCredencialesQueryHandler.cs
‚îÇ   ‚îî‚îÄ‚îÄ ValidarCorreo/
‚îÇ       ‚îú‚îÄ‚îÄ ValidarCorreoQuery.cs
‚îÇ       ‚îî‚îÄ‚îÄ ValidarCorreoQueryHandler.cs
‚îú‚îÄ‚îÄ DTOs/
‚îÇ   ‚îú‚îÄ‚îÄ LoginResult.cs
‚îÇ   ‚îú‚îÄ‚îÄ PerfilDto.cs
‚îÇ   ‚îú‚îÄ‚îÄ CuentaDto.cs
‚îÇ   ‚îî‚îÄ‚îÄ CredencialDto.cs
‚îî‚îÄ‚îÄ Validators/
    ‚îî‚îÄ‚îÄ (validators ya incluidos en carpetas de Commands)

src/Presentation/MiGenteEnLinea.API/Controllers/
‚îî‚îÄ‚îÄ AuthController.cs (11 endpoints)
```

### Ejemplo Completo: LoginCommand

#### 1. LoginCommand.cs
```csharp
namespace MiGenteEnLinea.Application.Features.Authentication.Commands.Login;

public record LoginCommand(string Email, string Password) : IRequest<LoginResult>;
```

#### 2. LoginCommandHandler.cs
```csharp
using MediatR;
using Microsoft.EntityFrameworkCore;
using MiGenteEnLinea.Application.Common.Interfaces;
using MiGenteEnLinea.Infrastructure.Persistence.Contexts;

namespace MiGenteEnLinea.Application.Features.Authentication.Commands.Login;

public class LoginCommandHandler : IRequestHandler<LoginCommand, LoginResult>
{
    private readonly MiGenteDbContext _context;
    private readonly IPasswordHasher _passwordHasher;

    public LoginCommandHandler(MiGenteDbContext context, IPasswordHasher passwordHasher)
    {
        _context = context;
        _passwordHasher = passwordHasher;
    }

    public async Task<LoginResult> Handle(LoginCommand request, CancellationToken cancellationToken)
    {
        // L√ìGICA COPIADA DE: LoginService.asmx.cs -> login(string email, string pass)
        
        // 1. Buscar credencial por email
        var credencial = await _context.Credenciales
            .Where(x => x.Email == request.Email)
            .FirstOrDefaultAsync(cancellationToken);

        if (credencial == null)
            return new LoginResult { StatusCode = 0 }; // Credenciales inv√°lidas

        // 2. Verificar password (BCrypt en lugar de Crypt legacy)
        if (!_passwordHasher.VerifyPassword(request.Password, credencial.PasswordHash))
            return new LoginResult { StatusCode = 0 }; // Credenciales inv√°lidas

        // 3. Verificar si est√° activo
        if (!credencial.Activo)
            return new LoginResult { StatusCode = -1 }; // Cuenta inactiva

        // 4. Obtener datos de cuenta
        var cuenta = await _context.Cuentas
            .Where(x => x.UserId == credencial.UserId)
            .FirstOrDefaultAsync(cancellationToken);

        if (cuenta == null)
            return new LoginResult { StatusCode = 0 }; // Cuenta no encontrada

        // 5. Obtener datos de suscripci√≥n (IGUAL AL LEGACY)
        var suscripcion = await _context.Suscripciones
            .Include(s => s.PlanEmpleador) // Eager loading
            .Where(x => x.UserId == credencial.UserId)
            .OrderByDescending(x => x.SuscripcionId)
            .FirstOrDefaultAsync(cancellationToken);

        int? planId = 0;
        DateTime? vencimientoPlan = null;
        int? nomina = null;
        int? empleados = null;
        bool? historico = null;

        if (suscripcion != null)
        {
            planId = suscripcion.PlanId;
            vencimientoPlan = suscripcion.Vencimiento;
            nomina = suscripcion.PlanEmpleador?.Nomina;
            empleados = suscripcion.PlanEmpleador?.Empleados;
            historico = suscripcion.PlanEmpleador?.Historico;
        }

        // 6. Obtener perfil (VPerfiles view)
        var perfil = await _context.VPerfiles
            .Where(x => x.UserId == credencial.UserId)
            .FirstOrDefaultAsync(cancellationToken);

        // 7. Retornar resultado (ESTRUCTURA IGUAL AL LEGACY)
        return new LoginResult
        {
            StatusCode = 2, // Success
            UserId = credencial.UserId,
            Email = credencial.Email,
            Nombre = $"{cuenta.Nombre} {cuenta.Apellido}",
            Tipo = cuenta.Tipo,
            PlanId = planId,
            VencimientoPlan = vencimientoPlan,
            Nomina = nomina,
            Empleados = empleados,
            Historico = historico,
            Perfil = perfil != null ? new PerfilDto
            {
                // Mapear propiedades de VPerfiles
                UserId = perfil.UserId,
                EmailUsuario = perfil.EmailUsuario,
                Nombre = perfil.Nombre,
                // ... m√°s propiedades seg√∫n VPerfiles
            } : null
        };
    }
}
```

#### 3. LoginCommandValidator.cs
```csharp
using FluentValidation;

namespace MiGenteEnLinea.Application.Features.Authentication.Commands.Login;

public class LoginCommandValidator : AbstractValidator<LoginCommand>
{
    public LoginCommandValidator()
    {
        RuleFor(x => x.Email)
            .NotEmpty().WithMessage("El correo electr√≥nico es requerido")
            .EmailAddress().WithMessage("El correo electr√≥nico no es v√°lido")
            .MaximumLength(100).WithMessage("El correo no puede exceder 100 caracteres");

        RuleFor(x => x.Password)
            .NotEmpty().WithMessage("La contrase√±a es requerida")
            .MinimumLength(6).WithMessage("La contrase√±a debe tener al menos 6 caracteres")
            .MaximumLength(100).WithMessage("La contrase√±a no puede exceder 100 caracteres");
    }
}
```

#### 4. LoginResult.cs (DTO)
```csharp
namespace MiGenteEnLinea.Application.Features.Authentication.DTOs;

public class LoginResult
{
    public int StatusCode { get; set; } // 2=success, 0=invalid, -1=inactive
    public string? UserId { get; set; }
    public string? Email { get; set; }
    public string? Nombre { get; set; }
    public int? Tipo { get; set; } // 1=Empleador, 2=Contratista
    public int? PlanId { get; set; }
    public DateTime? VencimientoPlan { get; set; }
    public int? Nomina { get; set; }
    public int? Empleados { get; set; }
    public bool? Historico { get; set; }
    public PerfilDto? Perfil { get; set; }
}

public class PerfilDto
{
    public string? UserId { get; set; }
    public string? EmailUsuario { get; set; }
    public string? Nombre { get; set; }
    // ... m√°s propiedades seg√∫n VPerfiles
}
```

#### 5. AuthController.cs (Endpoint)
```csharp
using MediatR;
using Microsoft.AspNetCore.Mvc;
using MiGenteEnLinea.Application.Features.Authentication.Commands.Login;

namespace MiGenteEnLinea.API.Controllers;

[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IMediator _mediator;
    private readonly ILogger<AuthController> _logger;

    public AuthController(IMediator mediator, ILogger<AuthController> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }

    /// <summary>
    /// Autenticar usuario con email y contrase√±a
    /// </summary>
    /// <param name="command">Credenciales de login</param>
    /// <returns>Resultado de autenticaci√≥n</returns>
    [HttpPost("login")]
    [ProducesResponseType(typeof(LoginResult), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<ActionResult<LoginResult>> Login([FromBody] LoginCommand command)
    {
        _logger.LogInformation("Intento de login para email: {Email}", command.Email);

        var result = await _mediator.Send(command);

        if (result.StatusCode == 0)
        {
            _logger.LogWarning("Login fallido - Credenciales inv√°lidas para: {Email}", command.Email);
            return Unauthorized(new { message = "Credenciales inv√°lidas" });
        }

        if (result.StatusCode == -1)
        {
            _logger.LogWarning("Login fallido - Cuenta inactiva para: {Email}", command.Email);
            return Unauthorized(new { message = "Cuenta inactiva. Contacte al administrador." });
        }

        _logger.LogInformation("Login exitoso para usuario: {UserId}", result.UserId);
        return Ok(result);
    }

    // ... otros 10 endpoints para los dem√°s m√©todos de LoginService
}
```

### Validaci√≥n LOTE 1

```bash
# Compilar
cd "C:\Users\ray\OneDrive\Documents\ProyectoMigente\MiGenteEnLinea.Clean"
dotnet build --no-restore

# Ejecutar API
cd src/Presentation/MiGenteEnLinea.API
dotnet run

# Probar endpoint en Swagger
# http://localhost:5015/swagger/index.html
# POST /api/auth/login
# Body: { "email": "test@example.com", "password": "Test123!" }

# Validar logs
cat logs/migente-*.txt | grep "Login"
```

### Criterios de √âxito LOTE 1

- [ ] 11 Commands/Queries creados
- [ ] 11 Handlers implementados
- [ ] 11 Validators creados
- [ ] 4 DTOs creados
- [ ] AuthController con 11 endpoints funcionando
- [ ] dotnet build sin errores
- [ ] Swagger UI muestra todos los endpoints
- [ ] Login endpoint responde correctamente (200 OK o 401)
- [ ] Logs muestran eventos de autenticaci√≥n
- [ ] Documento `LOTE_1_AUTHENTICATION_COMPLETADO.md` creado

---

## üü† LOTE 2: EMPLEADORES (ALTA PRIORIDAD)

**Prioridad:** üü† **ALTA**  
**Prerequisito:** ‚úÖ LOTE 1 completado  
**Servicio Legacy:** (Varios archivos en Empleador/)  
**Duraci√≥n Estimada:** 3-4 horas  
**Estado:** ‚è≥ PENDIENTE

### M√©todos a Migrar (6-8 m√©todos estimados)

| # | M√©todo/Operaci√≥n | Command/Query | Descripci√≥n | Archivo Legacy |
|---|------------------|---------------|-------------|----------------|
| 1 | Crear Empleador | **CrearEmpleadorCommand** | INSERT Empleador | (a identificar) |
| 2 | Actualizar Empleador | **ActualizarEmpleadorCommand** | UPDATE Empleador | (a identificar) |
| 3 | Obtener Empleador por ID | **GetEmpleadorByIdQuery** | SELECT por ID | (a identificar) |
| 4 | Obtener Empleadores de Usuario | **GetEmpleadoresByUserQuery** | SELECT por userID | (a identificar) |
| 5 | Eliminar Empleador | **EliminarEmpleadorCommand** | Soft delete | (a identificar) |
| 6 | Buscar Empleadores | **BuscarEmpleadoresQuery** | B√∫squeda filtrada | (a identificar) |

**Nota:** Identificar archivos Legacy exactos al comenzar LOTE 2.

---

## üü† LOTE 3: CONTRATISTAS (ALTA PRIORIDAD)

**Prioridad:** üü† **ALTA**  
**Prerequisito:** ‚úÖ LOTE 2 completado  
**Servicio Legacy:** `ContratistasService.cs`  
**Ubicaci√≥n:** `Codigo Fuente Mi Gente/MiGente_Front/Services/ContratistasService.cs`  
**Duraci√≥n Estimada:** 4-5 horas  
**Estado:** ‚è≥ PENDIENTE

### M√©todos a Migrar (10 total)

| # | M√©todo Legacy | Operaci√≥n | Command/Query | Descripci√≥n |
|---|---------------|-----------|---------------|-------------|
| 1 | `getTodasUltimos20()` | READ | **GetUltimosContratistasQuery** | √öltimos 20 activos |
| 2 | `getMiPerfil(string userID)` | READ | **GetMiPerfilContratistaQuery** | Perfil del contratista |
| 3 | `getServicios(int contratistaID)` | READ | **GetServiciosContratistaQuery** | Servicios ofrecidos |
| 4 | `agregarServicio(Contratistas_Servicios)` | WRITE | **AgregarServicioCommand** | Agregar servicio |
| 5 | `removerServicio(int servicioID, int contratistaID)` | WRITE | **RemoverServicioCommand** | Eliminar servicio |
| 6 | `GuardarPerfil(Contratistas ct, string userID)` | WRITE | **GuardarPerfilContratistaCommand** | Actualizar perfil |
| 7 | `ActivarPerfil(string userID)` | WRITE | **ActivarPerfilContratistaCommand** | Activar perfil |
| 8 | `DesactivarPerfil(string userID)` | WRITE | **DesactivarPerfilContratistaCommand** | Desactivar perfil |
| 9 | `getConCriterio(string palabrasClave, string zona)` | READ | **BuscarContratistasQuery** | B√∫squeda filtrada |

---

## üü° LOTE 4: EMPLEADOS Y N√ìMINA (MEDIA PRIORIDAD)

**Prioridad:** üü° **MEDIA**  
**Prerequisito:** ‚úÖ LOTE 3 completado  
**Servicio Legacy:** `EmpleadosService.cs`  
**Ubicaci√≥n:** `Codigo Fuente Mi Gente/MiGente_Front/Services/EmpleadosService.cs`  
**Duraci√≥n Estimada:** 6-8 horas  
**Estado:** ‚è≥ PENDIENTE

### M√©todos a Migrar (15 total)

| # | M√©todo Legacy | Operaci√≥n | Command/Query | Complejidad |
|---|---------------|-----------|---------------|-------------|
| 1 | `getEmpleados(string userID)` | READ | **GetEmpleadosQuery** | Baja |
| 2 | `getVEmpleados(string userID)` | READ | **GetVEmpleadosQuery** | Baja |
| 3 | `getContrataciones(Guid userID)` | READ | **GetContratacionesQuery** | Media |
| 4 | `getEmpleadosByID(Guid userID, int id)` | READ | **GetEmpleadoByIdQuery** | Baja |
| 5 | `obtenerRemuneraciones(string userID, int empleadoID)` | READ | **GetRemuneracionesQuery** | Baja |
| 6 | `quitarRemuneracion(string userID, int id)` | WRITE | **QuitarRemuneracionCommand** | Baja |
| 7 | `guardarEmpleado(Empleados empleado)` | WRITE | **GuardarEmpleadoCommand** | Media |
| 8 | `actualizarEmpleado(Empleados empleado)` | WRITE | **ActualizarEmpleadoCommand** | Media |
| 9 | `ActualizarEmpleado(Empleados empleado)` | WRITE | (duplicado, ignorar) | - |
| 10 | `procesarPago(Header, Detalle)` | WRITE | **ProcesarPagoCommand** | üî¥ ALTA |
| 11 | `procesarPagoContratacion(Header, Detalle)` | WRITE | **ProcesarPagoContratacionCommand** | üî¥ ALTA |

**Nota:** `procesarPago` y `procesarPagoContratacion` son operaciones complejas con m√∫ltiples tablas. Requieren atenci√≥n especial.

---

## üü° LOTE 5: SUSCRIPCIONES Y PAGOS (MEDIA PRIORIDAD)

**Prioridad:** üü° **MEDIA**  
**Prerequisito:** ‚úÖ LOTE 4 completado  
**Servicios Legacy:** `SuscripcionesService.cs`, `PaymentService.cs`, `CalificacionesService.cs`  
**Duraci√≥n Estimada:** 5-6 horas  
**Estado:** ‚è≥ PENDIENTE

### M√©todos a Migrar (19 m√©todos total)

**SuscripcionesService.cs (8 m√©todos)**
**PaymentService.cs (5 m√©todos)**
**CalificacionesService.cs (6 m√©todos)**

---

## üü¢ LOTE 6: SERVICIOS AUXILIARES (BAJA PRIORIDAD)

**Prioridad:** üü¢ **BAJA**  
**Prerequisito:** ‚úÖ LOTE 5 completado  
**Servicios:** `EmailService.cs`, `Utilitario.cs`, otros auxiliares  
**Duraci√≥n Estimada:** 3-4 horas  
**Estado:** ‚è≥ PENDIENTE

---

## üü¢ LOTE 7: BOT Y SERVICIOS AVANZADOS (BAJA PRIORIDAD)

**Prioridad:** üü¢ **BAJA**  
**Prerequisito:** ‚úÖ LOTE 6 completado  
**Servicios:** `BotServices.cs`, `botService.asmx.cs` (OpenAI integration)  
**Duraci√≥n Estimada:** 2-3 horas  
**Estado:** ‚è≥ PENDIENTE

---

## üìã COMANDO DE EJECUCI√ìN (PARA AGENTE AUT√ìNOMO)

### Comando para LOTE 1 (Authentication)

```
@workspace Lee prompts/APPLICATION_LAYER_CQRS_IMPLEMENTATION.md

EJECUTAR: LOTE 1 completo (Authentication)

OBJETIVO: Migrar 11 m√©todos de LoginService.asmx.cs a CQRS con MediatR

METODOLOG√çA ESTRICTA:
1. LEER Codigo Fuente Mi Gente/MiGente_Front/Services/LoginService.asmx.cs
2. IDENTIFICAR los 11 m√©todos p√∫blicos listados en la tabla
3. Para CADA m√©todo:
   a. ANALIZAR la l√≥gica paso a paso
   b. CREAR Command o Query seg√∫n operaci√≥n
   c. CREAR Handler con l√≥gica ID√âNTICA al Legacy
   d. CREAR Validator con FluentValidation
   e. CREAR DTOs necesarios
   f. CREAR endpoint en AuthController
4. COMPILAR: dotnet build --no-restore (debe ser exitoso)
5. EJECUTAR: dotnet run (verificar API arranca)
6. PROBAR: Swagger UI - endpoint /api/auth/login
7. DOCUMENTAR: Crear LOTE_1_AUTHENTICATION_COMPLETADO.md

PATR√ìN DE REFERENCIA:
Seguir el ejemplo completo de LoginCommand (incluido arriba).
La l√≥gica en Handler DEBE SER ID√âNTICA al m√©todo login() en LoginService.asmx.cs

AUTORIZACI√ìN COMPLETA:
- Leer todos los archivos Legacy necesarios
- Crear todos los archivos en Application Layer
- Crear AuthController en API Layer
- Ejecutar dotnet build y dotnet run
- NO aplicar migraciones (solo uso de DbContext existente)

DURACI√ìN ESTIMADA: 4-6 horas

CRITERIO DE √âXITO:
- 11 Commands/Queries funcionando
- 11 endpoints en AuthController
- dotnet build sin errores
- Swagger UI accesible
- Login endpoint funcional

COMENZAR EJECUCI√ìN AUTOM√ÅTICA AHORA.
```

---

## üìä M√âTRICAS Y PROGRESO

### Estimaci√≥n Total

| Lote | Prioridad | M√©todos | Duraci√≥n | Estado |
|------|-----------|---------|----------|--------|
| **LOTE 1** | üî¥ CR√çTICA | 11 | 4-6h | ‚è≥ Pendiente |
| **LOTE 2** | üü† ALTA | 6-8 | 3-4h | üö´ Bloqueado |
| **LOTE 3** | üü† ALTA | 10 | 4-5h | üö´ Bloqueado |
| **LOTE 4** | üü° MEDIA | 15 | 6-8h | üö´ Bloqueado |
| **LOTE 5** | üü° MEDIA | 19 | 5-6h | üö´ Bloqueado |
| **LOTE 6** | üü¢ BAJA | 10-12 | 3-4h | üö´ Bloqueado |
| **LOTE 7** | üü¢ BAJA | 3-5 | 2-3h | üö´ Bloqueado |
| **TOTAL** | - | **74-80** | **27-36h** | **0% Complete** |

### Progreso Visual

```
LOTE 1 (Authentication):        ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% (0/11)
LOTE 2 (Empleadores):           ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% (0/8)
LOTE 3 (Contratistas):          ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% (0/10)
LOTE 4 (Empleados/N√≥mina):      ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% (0/15)
LOTE 5 (Suscripciones/Pagos):   ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% (0/19)
LOTE 6 (Servicios Auxiliares):  ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% (0/12)
LOTE 7 (Bot/Avanzados):         ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% (0/5)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
TOTAL IMPLEMENTADO:             ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% (0/80)
```

---

## ‚úÖ CHECKLIST GENERAL

### Pre-Ejecuci√≥n (antes de LOTE 1)

- [ ] Domain Layer completo (36 entidades) ‚úÖ
- [ ] Infrastructure configurado (relaciones) ‚úÖ
- [ ] Program.cs configurado (MediatR, FluentValidation, AutoMapper) ‚úÖ
- [ ] API ejecut√°ndose en puerto 5015 ‚úÖ
- [ ] Swagger UI accesible ‚úÖ
- [ ] Leer este documento completo
- [ ] Entender metodolog√≠a de paridad con Legacy
- [ ] Ubicar archivos Legacy en `Codigo Fuente Mi Gente/`

### Post-Ejecuci√≥n (despu√©s de cada LOTE)

- [ ] Todos los Commands/Queries creados
- [ ] Todos los Handlers implementados con l√≥gica Legacy
- [ ] Todos los Validators creados
- [ ] DTOs necesarios creados
- [ ] Controller con endpoints funcionando
- [ ] `dotnet build` sin errores
- [ ] `dotnet run` - API ejecut√°ndose
- [ ] Swagger UI muestra nuevos endpoints
- [ ] Probar al menos 3 endpoints con Postman/Swagger
- [ ] Logs muestran operaciones
- [ ] Documento `LOTE_X_COMPLETADO.md` creado

---

## üö® NOTAS IMPORTANTES

### Sobre Paridad con Legacy

**‚ö†Ô∏è REGLA DE ORO: NO INNOVAR SIN AUTORIZACI√ìN**

- Si el Legacy hace `db.SaveChanges()` dos veces separadas, hacerlo igual
- Si el Legacy retorna c√≥digos num√©ricos (2, 0, -1), mantenerlos igual
- Si el Legacy usa nombres en espa√±ol, mantenerlos igual
- Si el Legacy tiene l√≥gica "fea" pero funcional, copiarla tal cual

**Ejemplos de HACER:**
```csharp
// Legacy usa c√≥digos num√©ricos
if (result == null) return 0;
if (!result.activo) return -1;
return 2;

// Clean debe hacer lo mismo
public class LoginResult 
{
    public int StatusCode { get; set; } // 2=success, 0=invalid, -1=inactive
}
```

**Ejemplos de NO HACER:**
```csharp
// ‚ùå NO cambiar c√≥digos a bool/enum sin autorizaci√≥n
public class LoginResult 
{
    public bool IsSuccess { get; set; } // ‚ùå Legacy usa int
    public LoginStatus Status { get; set; } // ‚ùå Legacy no usa enum
}
```

### Sobre Encriptaci√≥n de Passwords

**Legacy usa:** `Crypt.Encrypt(pass)` (custom encryption)  
**Clean usa:** `BCrypt.Net.BCrypt.HashPassword(password, 12)` (modern hashing)

**‚ö†Ô∏è IMPORTANTE:** Durante la migraci√≥n gradual, la base de datos tendr√°:
- Passwords antiguos con `Crypt` (legacy)
- Passwords nuevos con `BCrypt` (clean)

**Soluci√≥n temporal en Handler:**
```csharp
// Intentar BCrypt primero (nuevo est√°ndar)
if (credencial.PasswordHash.StartsWith("$2a$") || credencial.PasswordHash.StartsWith("$2b$"))
{
    // Es BCrypt
    if (!_passwordHasher.VerifyPassword(request.Password, credencial.PasswordHash))
        return new LoginResult { StatusCode = 0 };
}
else
{
    // Es legacy Crypt - usar servicio de compatibilidad
    var crypt = new LegacyCrypt();
    var crypted = crypt.Encrypt(request.Password);
    if (credencial.PasswordHash != crypted)
        return new LoginResult { StatusCode = 0 };
}
```

### Sobre Queries EF Core

**Legacy usa:**
```csharp
var result = db.Credenciales.Where(x => x.email == email && x.password == crypted).FirstOrDefault();
```

**Clean debe usar:**
```csharp
var credencial = await _context.Credenciales
    .Where(x => x.Email == request.Email)
    .FirstOrDefaultAsync(cancellationToken);
```

**Diferencias clave:**
- `.FirstOrDefault()` ‚Üí `.FirstOrDefaultAsync(cancellationToken)`
- Propiedades en PascalCase (convenci√≥n C#): `email` ‚Üí `Email`
- Siempre usar `await` y `CancellationToken`

### Sobre Views (VPerfiles, VEmpleados, VContratistas)

Las **views** del Legacy (`VPerfiles`, `VEmpleados`, etc.) est√°n en el DbContext como **Read Models**. Se usan para consultas optimizadas.

**Legacy:**
```csharp
var perfil = db.VPerfiles.Where(a => a.userID == userID).FirstOrDefault();
```

**Clean:**
```csharp
var perfil = await _context.VPerfiles
    .Where(x => x.UserId == request.UserId)
    .AsNoTracking() // Read-only
    .FirstOrDefaultAsync(cancellationToken);
```

**Usar `.AsNoTracking()` en Queries** para mejor performance (no tracking de cambios).

---

## üìû SOPORTE Y TROUBLESHOOTING

### Problemas Comunes

#### Problema 1: "No se encuentra el namespace MiGenteEnLinea.Application.Features.X"

**Causa:** Carpeta no creada o namespace incorrecto.

**Soluci√≥n:**
```csharp
// Crear estructura de carpetas:
Features/
  Authentication/
    Commands/
      Login/

// Namespace correcto:
namespace MiGenteEnLinea.Application.Features.Authentication.Commands.Login;
```

#### Problema 2: "MediatR no est√° registrado"

**Causa:** DependencyInjection.cs no llamado en Program.cs

**Soluci√≥n:**
```csharp
// En Program.cs
builder.Services.AddApplication(); // Debe estar presente
```

#### Problema 3: "Handler no se ejecuta"

**Causa:** Handler no implementa `IRequestHandler<TRequest, TResponse>`

**Soluci√≥n:**
```csharp
public class LoginCommandHandler : IRequestHandler<LoginCommand, LoginResult>
{
    public async Task<LoginResult> Handle(LoginCommand request, CancellationToken ct)
    {
        // ...
    }
}
```

#### Problema 4: "Validator no se ejecuta autom√°ticamente"

**Causa:** Behavior de validaci√≥n no configurado

**Soluci√≥n:**
```csharp
// En Application/DependencyInjection.cs
services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());

// Agregar ValidationBehavior (opcional - para validaci√≥n autom√°tica pre-handler)
services.AddTransient(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
```

---

## üéØ PR√ìXIMO PASO

**üöÄ COMENZAR CON LOTE 1 (AUTHENTICATION)**

Copiar el **Comando de Ejecuci√≥n para LOTE 1** (arriba) y ejecutarlo en Claude Sonnet 4.5 en modo agente.

**Duraci√≥n esperada:** 4-6 horas  
**Output esperado:** AuthController con 11 endpoints funcionando, documento LOTE_1_AUTHENTICATION_COMPLETADO.md

---

_Documento creado: 2025-10-12_  
_√öltima actualizaci√≥n: 2025-10-12_  
_Estado: Listo para ejecuci√≥n_
